<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>3D Ghost Character - Fixed Version</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c0c 0%, #2d1b69 50%, #0c0c0c 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #renderCanvas, canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #fallbackMessage {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">Loading Ghost...</div>
    <div id="fallbackMessage">Using Canvas fallback (WebGL not available)</div>
    <canvas id="renderCanvas"></canvas>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // WebGL detection
        function detectWebGL() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl && gl instanceof WebGLRenderingContext) {
                    return true;
                }
            } catch (e) {
                console.log('WebGL detection error:', e);
            }
            return false;
        }

        // Canvas 2D Fallback Ghost
        class CanvasGhost {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.time = 0;
                this.mouseX = canvas.width / 2;
                this.mouseY = canvas.height / 2;
                this.ghost = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    scale: 1,
                    eyeBlink: false
                };
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                canvas.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
                canvas.addEventListener('click', () => this.onClick());
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            onClick() {
                document.getElementById('info').textContent = 'Boo! I am a ghost!';
                this.ghost.scale = 1.2;
                setTimeout(() => {
                    document.getElementById('info').textContent = 'Canvas Ghost - Click to interact!';
                    this.ghost.scale = 1;
                }, 2000);
            }
            
            draw() {
                const ctx = this.ctx;
                
                // Clear canvas
                ctx.fillStyle = '#0d0d1f';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw gradient background
                const gradient = ctx.createRadialGradient(this.canvas.width/2, this.canvas.height/2, 0, this.canvas.width/2, this.canvas.height/2, this.canvas.width/2);
                gradient.addColorStop(0, 'rgba(45, 27, 105, 0.3)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.save();
                ctx.translate(this.ghost.x, this.ghost.y);
                ctx.scale(this.ghost.scale, this.ghost.scale);
                
                const floatY = Math.sin(this.time * 2) * 10;
                ctx.translate(0, floatY);
                
                // Ghost body
                ctx.beginPath();
                ctx.fillStyle = 'rgba(240, 240, 255, 0.9)';
                ctx.strokeStyle = 'rgba(130, 130, 200, 0.5)';
                ctx.lineWidth = 2;
                
                ctx.arc(0, -50, 60, Math.PI, 0, false);
                ctx.lineTo(60, 20);
                
                for (let i = 0; i < 6; i++) {
                    const x = 60 - (i * 20);
                    const y = 20 + Math.sin(this.time * 3 + i) * 10;
                    ctx.quadraticCurveTo(x + 10, y - 5, x, y);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Inner glow
                const glowGradient = ctx.createRadialGradient(0, -20, 0, 0, -20, 80);
                glowGradient.addColorStop(0, 'rgba(150, 170, 255, 0.3)');
                glowGradient.addColorStop(1, 'rgba(150, 170, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fill();
                
                // Eyes
                const dx = (this.mouseX - this.ghost.x) * 0.01;
                const dy = (this.mouseY - this.ghost.y) * 0.01;
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(-20 + dx, -50 + dy, 8, this.ghost.eyeBlink ? 2 : 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(20 + dx, -50 + dy, 8, this.ghost.eyeBlink ? 2 : 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye glow
                ctx.fillStyle = 'rgba(100, 150, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(-20 + dx, -50 + dy - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(20 + dx, -50 + dy - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, -30, 15, 0, Math.PI, false);
                ctx.stroke();
                
                // Arms
                ctx.strokeStyle = 'rgba(240, 240, 255, 0.7)';
                ctx.lineWidth = 20;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(-40, -20);
                const leftArmX = -60 + Math.sin(this.time * 2) * 10;
                const leftArmY = 0 + Math.cos(this.time * 2) * 5;
                ctx.quadraticCurveTo(-50, -10, leftArmX, leftArmY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(40, -20);
                const rightArmX = 60 + Math.sin(this.time * 2 + 0.5) * 10;
                const rightArmY = 0 + Math.cos(this.time * 2 + 0.5) * 5;
                ctx.quadraticCurveTo(50, -10, rightArmX, rightArmY);
                ctx.stroke();
                
                // Particles
                ctx.fillStyle = 'rgba(150, 200, 255, 0.6)';
                for (let i = 0; i < 10; i++) {
                    const particleX = Math.sin(this.time + i) * 100;
                    const particleY = -100 + (this.time * 50 + i * 30) % 200;
                    const size = Math.sin(this.time * 2 + i) * 2 + 3;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            animate() {
                this.time += 0.016;
                
                if (Math.random() < 0.01) {
                    this.ghost.eyeBlink = true;
                    setTimeout(() => {
                        this.ghost.eyeBlink = false;
                    }, 150);
                }
                
                this.ghost.x += (this.mouseX - this.ghost.x) * 0.05;
                this.ghost.y += (this.mouseY - this.ghost.y) * 0.05;
                
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
            
            start() {
                document.getElementById('info').textContent = 'Canvas Ghost - Click to interact!';
                document.getElementById('fallbackMessage').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('fallbackMessage').style.display = 'none';
                }, 3000);
                this.animate();
            }
        }

        // WebGL Three.js Ghost
        class WebGLGhost {
            constructor(canvas) {
                this.canvas = canvas;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.ghost = null;
                this.time = 0;
                this.proceduralGhost = null;
            }
            
            createProceduralGhost() {
                const ghostGroup = new THREE.Group();
                
                // Ghost body
                const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
                bodyGeometry.scale(1, 1.5, 1);
                
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xf0f0ff,
                    emissive: 0x404080,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.85,
                    side: THREE.DoubleSide
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                ghostGroup.add(body);
                
                // Ghost tail
                const tailGeometry = new THREE.ConeGeometry(0.8, 1.5, 32, 1, true);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.y = -0.5;
                tail.rotation.z = Math.PI;
                ghostGroup.add(tail);
                
                // Wavy bottom
                for (let i = 0; i < 3; i++) {
                    const waveGeometry = new THREE.TorusGeometry(0.6 - i * 0.1, 0.1, 8, 32);
                    const wave = new THREE.Mesh(waveGeometry, bodyMaterial);
                    wave.position.y = -1.2 + i * 0.1;
                    wave.rotation.x = Math.PI / 2;
                    ghostGroup.add(wave);
                }
                
                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const eyeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: 0x222244,
                    emissiveIntensity: 0.5
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.3, 0.8, 0.8);
                ghostGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.3, 0.8, 0.8);
                ghostGroup.add(rightEye);
                
                // Eye glow
                const eyeGlowGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                const eyeGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x6699ff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                leftEyeGlow.position.set(-0.3, 0.8, 0.9);
                ghostGroup.add(leftEyeGlow);
                
                const rightEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                rightEyeGlow.position.set(0.3, 0.8, 0.9);
                ghostGroup.add(rightEyeGlow);
                
                // Mouth
                const mouthGeometry = new THREE.SphereGeometry(0.1, 16, 8);
                mouthGeometry.scale(1.5, 0.8, 0.5);
                const mouth = new THREE.Mesh(mouthGeometry, eyeMaterial);
                mouth.position.set(0, 0.5, 0.85);
                ghostGroup.add(mouth);
                
                // Arms
                const armGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                armGeometry.scale(1, 2, 0.5);
                
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.8, 0.3, 0);
                leftArm.rotation.z = 0.3;
                ghostGroup.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.8, 0.3, 0);
                rightArm.rotation.z = -0.3;
                ghostGroup.add(rightArm);
                
                // Particles
                const particleCount = 20;
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    particlePositions[i * 3] = (Math.random() - 0.5) * 3;
                    particlePositions[i * 3 + 1] = Math.random() * 2 - 0.5;
                    particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 3;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x88aaff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                ghostGroup.add(particles);
                
                ghostGroup.scale.set(1.5, 1.5, 1.5);
                
                ghostGroup.userData = {
                    body: body,
                    tail: tail,
                    leftEye: leftEye,
                    rightEye: rightEye,
                    leftArm: leftArm,
                    rightArm: rightArm,
                    particles: particles,
                    particlePositions: particlePositions
                };
                
                return ghostGroup;
            }
            
            init() {
                try {
                    // Create scene
                    this.scene = new THREE.Scene();
                    
                    // Create camera
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 5;
                    
                    // Create renderer
                    this.renderer = new THREE.WebGLRenderer({ 
                        canvas: this.canvas,
                        antialias: true,
                        alpha: false,
                        powerPreference: "high-performance",
                        failIfMajorPerformanceCaveat: false
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setClearColor(0x0d0d1f);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    // Create procedural ghost first
                    this.proceduralGhost = this.createProceduralGhost();
                    this.ghost = this.proceduralGhost;
                    this.scene.add(this.ghost);
                    
                    // Try to load GLB model
                    const loader = new THREE.GLTFLoader();
                    loader.load('assets/characters/Ghost/Mesh.glb', 
                        (gltf) => {
                            console.log('GLB loaded successfully');
                            this.scene.remove(this.ghost);
                            this.ghost = gltf.scene;
                            this.ghost.scale.set(3, 3, 3);
                            
                            this.ghost.traverse((child) => {
                                if (child.isMesh) {
                                    child.material = new THREE.MeshPhongMaterial({
                                        color: 0xf0f0ff,
                                        emissive: 0x404080,
                                        emissiveIntensity: 0.2,
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                }
                            });
                            
                            this.scene.add(this.ghost);
                            document.getElementById('info').textContent = 'GLB Ghost loaded! Click to interact.';
                        },
                        (progress) => {
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                                console.log(`Loading GLB... ${percent}%`);
                            }
                        },
                        (error) => {
                            console.log('GLB failed to load, using procedural ghost:', error);
                            document.getElementById('info').textContent = 'Procedural ghost ready! Click to interact.';
                        }
                    );
                    
                    // Add lights
                    const light = new THREE.DirectionalLight(0xffffff, 1);
                    light.position.set(1, 1, 1);
                    this.scene.add(light);
                    
                    const ambientLight = new THREE.AmbientLight(0x404040);
                    this.scene.add(ambientLight);
                    
                    // Update info
                    document.getElementById('info').textContent = 'Ghost manifested! Click to interact.';
                    
                    // Add click handler
                    document.addEventListener('click', () => {
                        document.getElementById('info').textContent = 'Boo! I am a ghost!';
                        setTimeout(() => {
                            document.getElementById('info').textContent = 'Ghost manifested! Click to interact.';
                        }, 2000);
                    });
                    
                    // Handle resize
                    window.addEventListener('resize', () => this.onWindowResize());
                    
                    // Start animation
                    this.animate();
                    
                } catch (error) {
                    console.error('WebGL initialization failed:', error);
                    throw error;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time += 0.01;
                
                if (this.ghost) {
                    if (this.ghost.userData && this.ghost.userData.body) {
                        // Procedural ghost animation
                        this.animateProceduralGhost();
                    } else {
                        // Simple animation for GLB
                        this.ghost.position.y = Math.sin(this.time * 2) * 0.3;
                        this.ghost.rotation.y += 0.005;
                        this.ghost.scale.x = 1 + Math.sin(this.time * 3) * 0.05;
                        this.ghost.scale.z = 1 + Math.sin(this.time * 3) * 0.05;
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            animateProceduralGhost() {
                const userData = this.ghost.userData;
                
                this.ghost.position.y = Math.sin(this.time * 1.2) * 0.3;
                this.ghost.rotation.y += 0.005;
                
                if (userData.leftArm) {
                    userData.leftArm.rotation.z = 0.3 + Math.sin(this.time * 2) * 0.2;
                }
                if (userData.rightArm) {
                    userData.rightArm.rotation.z = -0.3 - Math.sin(this.time * 2 + 0.5) * 0.2;
                }
                
                if (Math.sin(this.time * 0.5) > 0.98) {
                    userData.leftEye.scale.y = 0.1;
                    userData.rightEye.scale.y = 0.1;
                } else {
                    userData.leftEye.scale.y = 1;
                    userData.rightEye.scale.y = 1;
                }
                
                if (userData.particles && userData.particlePositions) {
                    const positions = userData.particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += 0.01;
                        if (positions[i + 1] > 2) {
                            positions[i + 1] = -0.5;
                        }
                    }
                    userData.particles.geometry.attributes.position.needsUpdate = true;
                }
                
                if (userData.tail) {
                    userData.tail.rotation.x = Math.sin(this.time * 3) * 0.05;
                    userData.tail.rotation.z = Math.PI + Math.sin(this.time * 2.5) * 0.05;
                }
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize the appropriate version
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('renderCanvas');
            
            if (detectWebGL()) {
                console.log('WebGL detected, using Three.js');
                try {
                    const webglGhost = new WebGLGhost(canvas);
                    webglGhost.init();
                } catch (error) {
                    console.error('WebGL failed, falling back to Canvas:', error);
                    const canvasGhost = new CanvasGhost(canvas);
                    canvasGhost.start();
                }
            } else {
                console.log('WebGL not available, using Canvas fallback');
                const canvasGhost = new CanvasGhost(canvas);
                canvasGhost.start();
            }
        });
    </script>
</body>
</html>
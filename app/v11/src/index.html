<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: #fff; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="info">Click to enable sound</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 1, 15);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Custom shader for ghost body
        const ghostVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
                vUv = uv;
                vNormal = normal;
                vPosition = position;
                
                vec3 pos = position;
                pos.x += sin(time * 2.0 + position.y * 3.0) * 0.1;
                pos.z += cos(time * 1.5 + position.y * 2.0) * 0.1;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;
        
        const ghostFragmentShader = `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                float glow = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                vec3 finalColor = color + vec3(0.3, 0.3, 0.8) * glow;
                
                float alpha = 0.6 + sin(time * 3.0 + vPosition.y * 5.0) * 0.2;
                alpha *= 0.8 + glow * 0.2;
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // Ghost group
        const ghostGroup = new THREE.Group();
        
        // Ghost material
        const ghostMaterial = new THREE.ShaderMaterial({
            vertexShader: ghostVertexShader,
            fragmentShader: ghostFragmentShader,
            transparent: true,
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Vector3(0.8, 0.8, 1.0) }
            }
        });

        // Ghost body with better geometry
        const bodyGeometry = new THREE.SphereGeometry(1, 64, 64);
        const body = new THREE.Mesh(bodyGeometry, ghostMaterial);
        ghostGroup.add(body);

        // Glowing eyes
        const eyeGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const eyeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff,
            emissive: 0xff00ff,
            emissiveIntensity: 2
        });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.3, 0.2, 0.8);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.3, 0.2, 0.8);
        
        // Eye glow
        const eyeGlowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const eyeGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.3
        });
        const leftEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
        leftEyeGlow.position.copy(leftEye.position);
        const rightEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
        rightEyeGlow.position.copy(rightEye.position);
        
        ghostGroup.add(leftEye, rightEye, leftEyeGlow, rightEyeGlow);

        // Flowing tail with custom geometry
        const tailCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, -0.5, 0.1),
            new THREE.Vector3(0.2, -1, 0),
            new THREE.Vector3(0, -1.5, -0.1),
            new THREE.Vector3(-0.1, -2, 0)
        ]);
        
        const tailGeometry = new THREE.TubeGeometry(tailCurve, 20, 0.5, 8, false);
        const tail = new THREE.Mesh(tailGeometry, ghostMaterial);
        ghostGroup.add(tail);

        // Particle system for ethereal effect
        const particleCount = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            particlePositions[i] = (Math.random() - 0.5) * 10;
            particlePositions[i + 1] = (Math.random() - 0.5) * 10;
            particlePositions[i + 2] = (Math.random() - 0.5) * 10;
            
            particleVelocities[i] = (Math.random() - 0.5) * 0.02;
            particleVelocities[i + 1] = Math.random() * 0.02;
            particleVelocities[i + 2] = (Math.random() - 0.5) * 0.02;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x8888ff,
            size: 0.05,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        scene.add(ghostGroup);
        camera.position.z = 5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222244, 0.5);
        scene.add(ambientLight);
        
        const ghostLight = new THREE.PointLight(0x8888ff, 1, 5);
        ghostGroup.add(ghostLight);

        // State management
        const state = {
            targetX: 0,
            targetY: 0,
            targetRotation: 0,
            emotion: 'ethereal',
            emotionTimer: 0,
            soundTimer: 0,
            particles: particlePositions,
            velocities: particleVelocities
        };

        // Advanced audio system
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function createGhostlySound() {
            const duration = 1.5;
            const oscillators = [];
            const gains = [];
            
            // Create multiple oscillators for rich sound
            for (let i = 0; i < 3; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100 + i * 50, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(
                    50 + i * 25, 
                    audioContext.currentTime + duration
                );
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + duration);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + duration);
                
                oscillators.push(osc);
                gains.push(gain);
            }
            
            // Add reverb-like effect with delay
            const delay = audioContext.createDelay(1);
            delay.delayTime.value = 0.3;
            const delayGain = audioContext.createGain();
            delayGain.gain.value = 0.3;
            
            gains[0].connect(delay);
            delay.connect(delayGain);
            delayGain.connect(audioContext.destination);
        }

        function updateEmotion(emotion) {
            state.emotion = emotion;
            
            switch(emotion) {
                case 'ethereal':
                    ghostMaterial.uniforms.color.value = new THREE.Vector3(0.8, 0.8, 1.0);
                    eyeMaterial.color = new THREE.Color(0x8888ff);
                    break;
                case 'mystical':
                    ghostMaterial.uniforms.color.value = new THREE.Vector3(1.0, 0.7, 0.9);
                    eyeMaterial.color = new THREE.Color(0xff00ff);
                    break;
                case 'ancient':
                    ghostMaterial.uniforms.color.value = new THREE.Vector3(0.7, 1.0, 0.7);
                    eyeMaterial.color = new THREE.Color(0x00ff00);
                    break;
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            ghostMaterial.uniforms.time.value = time;
            
            // Autonomous movement with sine waves
            if (Math.random() < 0.01) {
                state.targetX = (Math.random() - 0.5) * 6;
                state.targetY = (Math.random() - 0.5) * 3;
                state.targetRotation = (Math.random() - 0.5) * Math.PI;
            }
            
            // Smooth interpolation
            ghostGroup.position.x += (state.targetX - ghostGroup.position.x) * 0.02;
            ghostGroup.position.y += (state.targetY - ghostGroup.position.y) * 0.02;
            ghostGroup.rotation.y += (state.targetRotation - ghostGroup.rotation.y) * 0.02;
            
            // Complex floating pattern
            ghostGroup.position.y += Math.sin(time * 0.5) * 0.01 + Math.sin(time * 1.3) * 0.005;
            ghostGroup.position.x += Math.sin(time * 0.3) * 0.005;
            
            // Eye animations
            const eyePulse = 0.15 + Math.sin(time * 3) * 0.05;
            leftEye.scale.set(eyePulse, eyePulse, eyePulse);
            rightEye.scale.set(eyePulse, eyePulse, eyePulse);
            
            leftEyeGlow.scale.set(eyePulse * 2, eyePulse * 2, eyePulse * 2);
            rightEyeGlow.scale.set(eyePulse * 2, eyePulse * 2, eyePulse * 2);
            
            // Update particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] += state.velocities[i];
                positions[i + 1] += state.velocities[i + 1];
                positions[i + 2] += state.velocities[i + 2];
                
                // Wrap around
                if (positions[i + 1] > 5) positions[i + 1] = -5;
                if (Math.abs(positions[i]) > 5) positions[i] *= -0.9;
                if (Math.abs(positions[i + 2]) > 5) positions[i + 2] *= -0.9;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Emotion changes
            state.emotionTimer++;
            if (state.emotionTimer > 300) {
                const emotions = ['ethereal', 'mystical', 'ancient'];
                updateEmotion(emotions[Math.floor(Math.random() * emotions.length)]);
                state.emotionTimer = 0;
            }
            
            // Sound generation
            state.soundTimer++;
            if (state.soundTimer > 400 + Math.random() * 400) {
                createGhostlySound();
                state.soundTimer = 0;
            }
            
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Audio init
        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            document.getElementById('info').style.display = 'none';
        }, { once: true });

        animate();
    </script>
</body>
</html>

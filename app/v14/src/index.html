<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(180deg, #0a0a2e 0%, #1a1a3e 100%);
        }
        canvas { display: block; }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: #fff; 
            opacity: 0.5;
            font-size: 12px;
            z-index: 100;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="info">Click to enable sound</div>
    <div id="debug"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a2e, 5, 20);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
        scene.add(ambientLight);
        
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(5, 10, 8);
        keyLight.castShadow = true;
        scene.add(keyLight);
        
        const rimLight = new THREE.DirectionalLight(0x4444ff, 0.4);
        rimLight.position.set(-5, 5, -5);
        scene.add(rimLight);

        // Ghost group
        const ghost = new THREE.Group();
        
        // Create organic ghost shape using lathe geometry
        const ghostPoints = [];
        const segments = 10;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            let radius;
            
            if (t < 0.3) {
                // Head region - spherical
                radius = Math.sin(t * Math.PI / 0.3) * 0.9;
            } else if (t < 0.7) {
                // Body - slightly wider
                radius = 0.9 + Math.sin((t - 0.3) * Math.PI / 0.4) * 0.2;
            } else {
                // Bottom - wavy taper
                radius = (1 - t) * 1.2 + Math.sin(t * Math.PI * 3) * 0.1;
            }
            
            ghostPoints.push(new THREE.Vector2(radius, 2 - t * 3.5));
        }
        
        const ghostGeometry = new THREE.LatheGeometry(ghostPoints, 32);
        
        // Ghost material with subsurface scattering effect
        const ghostMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            emissive: 0x6666ff,
            emissiveIntensity: 0.15,
            transparent: true,
            opacity: 0.95,
            shininess: 30,
            specular: 0x222244
        });
        
        const ghostBody = new THREE.Mesh(ghostGeometry, ghostMaterial);
        ghostBody.castShadow = true;
        ghost.add(ghostBody);
        
        // Arms (more organic blob shapes)
        const armGeometry = new THREE.SphereGeometry(0.35, 16, 16);
        
        const leftArm = new THREE.Mesh(armGeometry, ghostMaterial);
        leftArm.position.set(-0.9, 0, 0);
        leftArm.scale.set(1.5, 0.7, 0.7);
        leftArm.castShadow = true;
        ghost.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, ghostMaterial);
        rightArm.position.set(0.9, 0, 0);
        rightArm.scale.set(1.5, 0.7, 0.7);
        rightArm.castShadow = true;
        ghost.add(rightArm);
        
        // Face group (always faces camera)
        const face = new THREE.Group();
        
        // Eye sockets (indented)
        const eyeSocketGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const eyeSocketMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x000000,
            emissive: 0x000033,
            emissiveIntensity: 0.5
        });
        
        const leftEyeSocket = new THREE.Mesh(eyeSocketGeometry, eyeSocketMaterial);
        leftEyeSocket.position.set(-0.35, 0.8, 0.7);
        leftEyeSocket.scale.z = 0.5;
        face.add(leftEyeSocket);
        
        const rightEyeSocket = new THREE.Mesh(eyeSocketGeometry, eyeSocketMaterial);
        rightEyeSocket.position.set(0.35, 0.8, 0.7);
        rightEyeSocket.scale.z = 0.5;
        face.add(rightEyeSocket);
        
        // Glowing pupils
        const pupilGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const pupilMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            emissive: 0xffffff
        });
        
        const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        leftPupil.position.set(-0.35, 0.8, 0.85);
        face.add(leftPupil);
        
        const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        rightPupil.position.set(0.35, 0.8, 0.85);
        face.add(rightPupil);
        
        // Mouth (organic shape)
        const mouthShape = new THREE.Shape();
        mouthShape.moveTo(-0.3, 0);
        mouthShape.quadraticCurveTo(0, -0.2, 0.3, 0);
        mouthShape.quadraticCurveTo(0, 0.1, -0.3, 0);
        
        const mouthGeometry = new THREE.ShapeGeometry(mouthShape);
        const mouthMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x000000,
            side: THREE.DoubleSide
        });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, 0.3, 0.9);
        face.add(mouth);
        
        ghost.add(face);
        
        // Ghost light
        const ghostLight = new THREE.PointLight(0x8888ff, 0.5, 5);
        ghostLight.position.y = 0.5;
        ghost.add(ghostLight);
        
        // Add to scene
        scene.add(ghost);
        ghost.position.y = 1.5;
        
        // Camera position
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 2, 0);

        // Floor shadow receiver
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Floating particles
        const particleCount = 100;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            particlePositions[i] = (Math.random() - 0.5) * 10;
            particlePositions[i + 1] = Math.random() * 5;
            particlePositions[i + 2] = (Math.random() - 0.5) * 10;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x8888ff,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // State management with viewer awareness
        const state = {
            homeBase: { x: 0, y: 1.5, z: 0 },
            velocity: { x: 0, y: 0, z: 0 },
            activity: 'idle',
            emotion: 'curious',
            awareness: 'unaware', // unaware, noticed, performing
            lookAtCamera: false,
            timers: {
                activity: 0,
                emotion: 0,
                sound: 0,
                blink: 0,
                awareness: 0,
                stare: 0
            },
            mousePos: { x: 0, y: 0 }
        };

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            state.mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
            state.mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Audio
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'boo':
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'giggle':
                    for(let i = 0; i < 4; i++) {
                        const o = audioContext.createOscillator();
                        const g = audioContext.createGain();
                        o.frequency.value = 400 + i * 100;
                        g.gain.setValueAtTime(0, now + i * 0.1);
                        g.gain.linearRampToValueAtTime(0.1, now + i * 0.1 + 0.05);
                        g.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.1);
                        o.connect(g);
                        g.connect(audioContext.destination);
                        o.start(now + i * 0.1);
                        o.stop(now + i * 0.1 + 0.1);
                    }
                    break;
                case 'hmm':
                    const hmm = audioContext.createOscillator();
                    const hmmGain = audioContext.createGain();
                    hmm.frequency.setValueAtTime(150, now);
                    hmm.frequency.setValueAtTime(180, now + 0.1);
                    hmm.frequency.setValueAtTime(150, now + 0.2);
                    hmmGain.gain.setValueAtTime(0.2, now);
                    hmmGain.gain.setValueAtTime(0.2, now + 0.2);
                    hmmGain.gain.linearRampToValueAtTime(0, now + 0.3);
                    hmm.connect(hmmGain);
                    hmmGain.connect(audioContext.destination);
                    hmm.start(now);
                    hmm.stop(now + 0.3);
                    break;
            }
        }

        function setActivity(newActivity) {
            state.activity = newActivity;
            state.timers.activity = 0;
            
            switch(newActivity) {
                case 'explore':
                    const angle = Math.random() * Math.PI * 2;
                    state.velocity.x = Math.cos(angle) * 0.02;
                    state.velocity.z = Math.sin(angle) * 0.02;
                    state.lookAtCamera = false;
                    break;
                case 'return':
                    const dx = state.homeBase.x - ghost.position.x;
                    const dz = state.homeBase.z - ghost.position.z;
                    const d = Math.sqrt(dx*dx + dz*dz) || 1;
                    state.velocity.x = (dx/d) * 0.03;
                    state.velocity.z = (dz/d) * 0.03;
                    state.lookAtCamera = true;
                    break;
                case 'perform':
                    state.velocity.x = 0;
                    state.velocity.z = 0;
                    state.lookAtCamera = true;
                    setEmotion('excited');
                    playSound('giggle');
                    break;
                case 'peek':
                    // Move to edge of screen and peek at viewer
                    state.velocity.x = 0.03;
                    state.velocity.z = 0;
                    state.lookAtCamera = true;
                    setEmotion('mischievous');
                    break;
                case 'hover':
                    state.velocity.x = 0;
                    state.velocity.z = 0;
                    state.lookAtCamera = true;
                    break;
                case 'idle':
                    state.velocity.x = 0;
                    state.velocity.z = 0;
                    state.lookAtCamera = Math.random() > 0.3; // 70% chance to look at camera
                    break;
            }
        }

        function setEmotion(emotion) {
            state.emotion = emotion;
            
            // Reset face first
            leftEyeSocket.scale.set(1, 1, 0.5);
            rightEyeSocket.scale.set(1, 1, 0.5);
            mouth.scale.set(1, 1, 1);
            mouth.rotation.z = 0;
            
            switch(emotion) {
                case 'happy':
                    mouth.scale.y = 1.2;
                    ghostMaterial.emissive.setHex(0x6666ff);
                    break;
                case 'curious':
                    leftEyeSocket.scale.set(1.2, 1.2, 0.5);
                    rightEyeSocket.scale.set(1.2, 1.2, 0.5);
                    mouth.scale.set(0.7, 0.7, 1);
                    ghostMaterial.emissive.setHex(0x66ff66);
                    break;
                case 'surprised':
                    leftEyeSocket.scale.set(1.5, 1.5, 0.5);
                    rightEyeSocket.scale.set(1.5, 1.5, 0.5);
                    mouth.scale.set(1.3, 1.5, 1);
                    ghostMaterial.emissive.setHex(0xff6666);
                    playSound('boo');
                    break;
                case 'sleepy':
                    leftEyeSocket.scale.y = 0.3;
                    rightEyeSocket.scale.y = 0.3;
                    mouth.scale.y = 0.5;
                    ghostMaterial.emissive.setHex(0x4444aa);
                    break;
                case 'mischievous':
                    leftEyeSocket.scale.set(0.8, 1.2, 0.5);
                    mouth.rotation.z = 0.2;
                    ghostMaterial.emissive.setHex(0xff66ff);
                    break;
                case 'excited':
                    mouth.scale.set(1.5, 1.5, 1);
                    ghostMaterial.emissive.setHex(0xffff66);
                    break;
            }
        }

        function updateAwareness() {
            // Check if mouse is moving
            const mouseMovement = Math.abs(state.mousePos.x) + Math.abs(state.mousePos.y);
            
            if (state.awareness === 'unaware' && mouseMovement > 0.5) {
                state.awareness = 'noticed';
                state.timers.awareness = 0;
                setEmotion('curious');
                playSound('hmm');
            } else if (state.awareness === 'noticed' && state.timers.awareness > 3) {
                state.awareness = 'performing';
                setActivity('perform');
            } else if (state.awareness === 'performing' && state.timers.awareness > 10) {
                state.awareness = 'unaware';
                state.timers.awareness = 0;
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Update timers
            for(let key in state.timers) {
                state.timers[key] += delta;
            }
            
            // Update awareness
            updateAwareness();
            
            // Activity state machine
            if (state.activity === 'idle' && state.timers.activity > 3) {
                const activities = state.awareness === 'performing' 
                    ? ['perform', 'peek', 'hover']
                    : ['explore', 'hover', 'peek'];
                setActivity(activities[Math.floor(Math.random() * activities.length)]);
            } else if (state.activity === 'explore' && state.timers.activity > 5) {
                setActivity('return');
            } else if (state.activity === 'return') {
                const dist = Math.abs(ghost.position.x) + Math.abs(ghost.position.z);
                if (dist < 0.5) {
                    setActivity('idle');
                }
            } else if (state.activity === 'peek' && ghost.position.x > 3) {
                state.velocity.x = -0.03;
            } else if (state.activity === 'peek' && ghost.position.x < -3) {
                setActivity('return');
            } else if ((state.activity === 'perform' || state.activity === 'hover') && 
                      state.timers.activity > 4) {
                setActivity('idle');
            }
            
            // Apply movement
            ghost.position.x += state.velocity.x;
            ghost.position.z += state.velocity.z;
            
            // Organic floating motion
            ghost.position.y = state.homeBase.y + 
                              Math.sin(time * 1.5) * 0.1 + 
                              Math.sin(time * 3.7) * 0.05;
            
            // Body rotation - mostly face camera
            if (state.lookAtCamera) {
                const targetRotation = Math.atan2(camera.position.x - ghost.position.x, 
                                                 camera.position.z - ghost.position.z);
                ghost.rotation.y += (targetRotation - ghost.rotation.y) * 0.1;
            } else if (Math.abs(state.velocity.x) > 0.01 || Math.abs(state.velocity.z) > 0.01) {
                const targetRotation = Math.atan2(state.velocity.x, state.velocity.z);
                ghost.rotation.y += (targetRotation - ghost.rotation.y) * 0.05;
            }
            
            // Face always looks at camera
            face.lookAt(camera.position);
            
            // Eye tracking mouse when aware
            if (state.awareness !== 'unaware') {
                leftPupil.position.x = -0.35 + state.mousePos.x * 0.05;
                leftPupil.position.y = 0.8 + state.mousePos.y * 0.05;
                rightPupil.position.x = 0.35 + state.mousePos.x * 0.05;
                rightPupil.position.y = 0.8 + state.mousePos.y * 0.05;
            }
            
            // Organic body deformation
            const deform = Math.sin(time * 2) * 0.02;
            ghostBody.scale.x = 1 + deform;
            ghostBody.scale.z = 1 - deform;
            
            // Arm movements
            if (state.activity === 'perform') {
                leftArm.rotation.z = -0.5 + Math.sin(time * 8) * 0.5;
                rightArm.rotation.z = 0.5 - Math.sin(time * 8 + 0.5) * 0.5;
            } else {
                leftArm.rotation.z = -0.3 + Math.sin(time * 3) * 0.2;
                rightArm.rotation.z = 0.3 - Math.sin(time * 3) * 0.2;
            }
            
            leftArm.position.y = Math.sin(time * 2 + 1) * 0.1;
            rightArm.position.y = Math.sin(time * 2) * 0.1;
            
            // Blinking
            if (state.timers.blink > 3 + Math.random() * 2) {
                leftEyeSocket.scale.y = 0.1;
                rightEyeSocket.scale.y = 0.1;
                setTimeout(() => {
                    leftEyeSocket.scale.y = state.emotion === 'sleepy' ? 0.3 : 1;
                    rightEyeSocket.scale.y = state.emotion === 'sleepy' ? 0.3 : 1;
                }, 150);
                state.timers.blink = 0;
            }
            
            // Emotion changes (less frequent when performing)
            if (state.timers.emotion > (state.awareness === 'performing' ? 10 : 5)) {
                if (state.awareness !== 'performing') {
                    const emotions = ['happy', 'curious', 'sleepy', 'mischievous'];
                    setEmotion(emotions[Math.floor(Math.random() * emotions.length)]);
                }
                state.timers.emotion = 0;
            }
            
            // Sound timer
            if (state.timers.sound > 8 + Math.random() * 4) {
                if (state.awareness === 'performing') {
                    playSound('giggle');
                } else {
                    playSound(Math.random() > 0.5 ? 'boo' : 'hmm');
                }
                state.timers.sound = 0;
            }
            
            // Update particles
            const pPositions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount * 3; i += 3) {
                pPositions[i + 1] -= 0.005;
                if (pPositions[i + 1] < 0) {
                    pPositions[i + 1] = 5;
                    pPositions[i] = (Math.random() - 0.5) * 10;
                    pPositions[i + 2] = (Math.random() - 0.5) * 10;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Debug info
            document.getElementById('debug').innerHTML = 
                `Activity: ${state.activity} | Emotion: ${state.emotion} | Awareness: ${state.awareness}`;
            
            renderer.render(scene, camera);
        }

        // Start
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            document.getElementById('info').style.display = 'none';
        }, { once: true });

        animate();
    </script>
</body>
</html>

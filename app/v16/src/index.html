<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0a0a2e;
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100vh;
            touch-action: none;
        }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: #fff; 
            opacity: 0.5;
            font-size: 12px;
            z-index: 100;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="info">Click to enable sound</div>
    <div id="debug"></div>
    <canvas id="renderCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/5.57.1/babylon.js"></script>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        // Create scene
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.04, 0.04, 0.12);
            scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
            scene.fogColor = scene.clearColor;
            scene.fogStart = 5;
            scene.fogEnd = 20;
            
            // Camera
            const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 3, -8), scene);
            camera.setTarget(new BABYLON.Vector3(0, 2, 0));
            
            // Lighting
            const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
            ambient.intensity = 0.6;
            ambient.diffuse = new BABYLON.Color3(0.5, 0.5, 0.8);
            
            const keyLight = new BABYLON.DirectionalLight("keyLight", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
            keyLight.intensity = 0.8;
            keyLight.position = new BABYLON.Vector3(5, 10, -5);
            
            const rimLight = new BABYLON.DirectionalLight("rimLight", new BABYLON.Vector3(0.5, -0.5, -1), scene);
            rimLight.intensity = 0.4;
            rimLight.diffuse = new BABYLON.Color3(0.4, 0.4, 1);
            
            // Enable shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, keyLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            
            // Ghost material
            const ghostMat = new BABYLON.StandardMaterial("ghostMat", scene);
            ghostMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
            ghostMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.6);
            ghostMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.3);
            ghostMat.alpha = 0.95;
            ghostMat.backFaceCulling = false;
            
            // Create ghost body with custom mesh
            const ghostBody = BABYLON.MeshBuilder.CreateSphere("body", {
                diameter: 2,
                segments: 32,
                updatable: true
            }, scene);
            
            // Deform sphere into ghost shape
            const positions = ghostBody.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const normals = [];
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                
                // Stretch vertically and taper
                let scale = 1;
                if (y > 0) {
                    scale = 1 - (y * 0.15); // Narrower at top
                    positions[i + 1] *= 1.3; // Stretch up
                } else {
                    scale = 1 + (Math.abs(y) * 0.4); // Wider at bottom
                    positions[i + 1] *= 1.1;
                }
                
                // Add wavy bottom
                if (y < -0.6) {
                    const angle = Math.atan2(x, z);
                    const wave = Math.sin(angle * 5) * 0.15 * (1 + y);
                    scale += wave;
                }
                
                positions[i] = x * scale;
                positions[i + 2] = z * scale;
            }
            
            ghostBody.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
            BABYLON.VertexData.ComputeNormals(positions, ghostBody.getIndices(), normals);
            ghostBody.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
            ghostBody.material = ghostMat;
            ghostBody.position.y = 2;
            
            shadowGenerator.addShadowCaster(ghostBody);
            
            // Ghost root for organization
            const ghostRoot = new BABYLON.TransformNode("ghostRoot", scene);
            ghostBody.parent = ghostRoot;
            
            // Arms
            const leftArm = BABYLON.MeshBuilder.CreateSphere("leftArm", {
                diameter: 0.6,
                segments: 16
            }, scene);
            leftArm.scaling = new BABYLON.Vector3(1.5, 0.8, 0.8);
            leftArm.position = new BABYLON.Vector3(-0.9, 2, 0);
            leftArm.material = ghostMat;
            leftArm.parent = ghostRoot;
            shadowGenerator.addShadowCaster(leftArm);
            
            const rightArm = BABYLON.MeshBuilder.CreateSphere("rightArm", {
                diameter: 0.6,
                segments: 16
            }, scene);
            rightArm.scaling = new BABYLON.Vector3(1.5, 0.8, 0.8);
            rightArm.position = new BABYLON.Vector3(0.9, 2, 0);
            rightArm.material = ghostMat;
            rightArm.parent = ghostRoot;
            shadowGenerator.addShadowCaster(rightArm);
            
            // Face group
            const faceGroup = new BABYLON.TransformNode("face", scene);
            faceGroup.parent = ghostBody;
            faceGroup.position = new BABYLON.Vector3(0, 0, 0.8);
            
            // Eyes
            const eyeMat = new BABYLON.StandardMaterial("eyeMat", scene);
            eyeMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            eyeMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
            
            const leftEye = BABYLON.MeshBuilder.CreateSphere("leftEye", {
                diameter: 0.25,
                segments: 16
            }, scene);
            leftEye.scaling = new BABYLON.Vector3(1, 1.5, 0.5);
            leftEye.position = new BABYLON.Vector3(-0.25, 0.4, 0);
            leftEye.material = eyeMat;
            leftEye.parent = faceGroup;
            
            const rightEye = BABYLON.MeshBuilder.CreateSphere("rightEye", {
                diameter: 0.25,
                segments: 16
            }, scene);
            rightEye.scaling = new BABYLON.Vector3(1, 1.5, 0.5);
            rightEye.position = new BABYLON.Vector3(0.25, 0.4, 0);
            rightEye.material = eyeMat;
            rightEye.parent = faceGroup;
            
            // Eye sparkles
            const sparkleMat = new BABYLON.StandardMaterial("sparkleMat", scene);
            sparkleMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            sparkleMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            
            const leftSparkle = BABYLON.MeshBuilder.CreateSphere("leftSparkle", {
                diameter: 0.08
            }, scene);
            leftSparkle.position = new BABYLON.Vector3(-0.2, 0.45, 0.1);
            leftSparkle.material = sparkleMat;
            leftSparkle.parent = faceGroup;
            
            const rightSparkle = BABYLON.MeshBuilder.CreateSphere("rightSparkle", {
                diameter: 0.08
            }, scene);
            rightSparkle.position = new BABYLON.Vector3(0.3, 0.45, 0.1);
            rightSparkle.material = sparkleMat;
            rightSparkle.parent = faceGroup;
            
            // Mouth
            const mouth = BABYLON.MeshBuilder.CreateTorus("mouth", {
                diameter: 0.4,
                thickness: 0.1,
                tessellation: 16
            }, scene);
            mouth.scaling = new BABYLON.Vector3(1, 0.5, 1);
            mouth.position = new BABYLON.Vector3(0, 0.1, 0);
            mouth.rotation.x = Math.PI / 2;
            mouth.material = eyeMat;
            mouth.parent = faceGroup;
            
            // Ghost glow
            const glow = new BABYLON.PointLight("glow", new BABYLON.Vector3(0, 2, 0), scene);
            glow.diffuse = new BABYLON.Color3(0.5, 0.5, 1);
            glow.intensity = 0.5;
            glow.parent = ghostRoot;
            
            // Ground (for shadows)
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: 50,
                height: 50
            }, scene);
            ground.position.y = -1;
            ground.receiveShadows = true;
            ground.isVisible = false;
            
            // Particle system
            const particleSystem = new BABYLON.ParticleSystem("particles", 200, scene);
            particleSystem.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==", scene);
            particleSystem.emitter = ghostRoot;
            particleSystem.minEmitBox = new BABYLON.Vector3(-5, 0, -5);
            particleSystem.maxEmitBox = new BABYLON.Vector3(5, 5, 5);
            particleSystem.color1 = new BABYLON.Color4(0.5, 0.5, 1, 0.5);
            particleSystem.color2 = new BABYLON.Color4(0.8, 0.8, 1, 0.5);
            particleSystem.minSize = 0.05;
            particleSystem.maxSize = 0.1;
            particleSystem.minLifeTime = 5;
            particleSystem.maxLifeTime = 10;
            particleSystem.emitRate = 20;
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            particleSystem.gravity = new BABYLON.Vector3(0, -0.5, 0);
            particleSystem.direction1 = new BABYLON.Vector3(-0.5, 1, -0.5);
            particleSystem.direction2 = new BABYLON.Vector3(0.5, 1, 0.5);
            particleSystem.minEmitPower = 0.1;
            particleSystem.maxEmitPower = 0.3;
            particleSystem.start();
            
            // State management
            const state = {
                homeBase: new BABYLON.Vector3(0, 0, 0),
                velocity: new BABYLON.Vector3(0, 0, 0),
                activity: 'idle',
                emotion: 'happy',
                awareness: 'casual',
                timers: {
                    activity: 0,
                    emotion: 0,
                    sound: 0,
                    blink: 0,
                    awareness: 0
                }
            };
            
            // Audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            function playSound(type) {
                const now = audioContext.currentTime;
                switch(type) {
                    case 'boo':
                        const boo = audioContext.createOscillator();
                        const booGain = audioContext.createGain();
                        boo.frequency.setValueAtTime(180, now);
                        boo.frequency.exponentialRampToValueAtTime(80, now + 0.7);
                        booGain.gain.setValueAtTime(0.3, now);
                        booGain.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
                        boo.connect(booGain);
                        booGain.connect(audioContext.destination);
                        boo.start(now);
                        boo.stop(now + 0.7);
                        break;
                    case 'giggle':
                        for(let i = 0; i < 5; i++) {
                            const g = audioContext.createOscillator();
                            const gGain = audioContext.createGain();
                            g.frequency.value = 400 + i * 80;
                            gGain.gain.setValueAtTime(0, now + i * 0.1);
                            gGain.gain.linearRampToValueAtTime(0.1, now + i * 0.1 + 0.05);
                            gGain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.1);
                            g.connect(gGain);
                            gGain.connect(audioContext.destination);
                            g.start(now + i * 0.1);
                            g.stop(now + i * 0.1 + 0.1);
                        }
                        break;
                }
            }
            
            function setActivity(newActivity) {
                state.activity = newActivity;
                state.timers.activity = 0;
                
                switch(newActivity) {
                    case 'wander':
                        const angle = Math.random() * Math.PI * 2;
                        state.velocity.x = Math.cos(angle) * 0.02;
                        state.velocity.z = Math.sin(angle) * 0.02;
                        break;
                    case 'zoom':
                        state.velocity.x = (Math.random() - 0.5) * 0.08;
                        state.velocity.z = (Math.random() - 0.5) * 0.04;
                        break;
                    case 'dance':
                        state.velocity.x = 0;
                        state.velocity.z = 0;
                        setEmotion('excited');
                        playSound('giggle');
                        break;
                    case 'return':
                        const dir = state.homeBase.subtract(ghostRoot.position).normalize();
                        state.velocity.x = dir.x * 0.03;
                        state.velocity.z = dir.z * 0.03;
                        break;
                    default:
                        state.velocity.x = 0;
                        state.velocity.z = 0;
                }
            }
            
            function setEmotion(emotion) {
                state.emotion = emotion;
                
                // Reset face
                leftEye.scaling.y = 1.5;
                rightEye.scaling.y = 1.5;
                mouth.scaling = new BABYLON.Vector3(1, 0.5, 1);
                
                switch(emotion) {
                    case 'happy':
                        mouth.scaling.x = 1.2;
                        ghostMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.6);
                        break;
                    case 'excited':
                        leftEye.scaling.y = 2;
                        rightEye.scaling.y = 2;
                        mouth.scaling = new BABYLON.Vector3(1.5, 0.8, 1);
                        ghostMat.emissiveColor = new BABYLON.Color3(0.6, 0.6, 0.3);
                        break;
                    case 'surprised':
                        leftEye.scaling.set(1.5, 2, 0.5);
                        rightEye.scaling.set(1.5, 2, 0.5);
                        mouth.scaling.y = 1;
                        ghostMat.emissiveColor = new BABYLON.Color3(0.6, 0.3, 0.3);
                        break;
                    case 'sleepy':
                        leftEye.scaling.y = 0.5;
                        rightEye.scaling.y = 0.5;
                        mouth.scaling.y = 0.3;
                        ghostMat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.4);
                        break;
                }
            }
            
            // Animation
            let time = 0;
            scene.registerBeforeRender(() => {
                const deltaTime = engine.getDeltaTime() / 1000;
                time += deltaTime;
                
                // Update timers
                for(let key in state.timers) {
                    state.timers[key] += deltaTime;
                }
                
                // Awareness system
                if (state.awareness === 'casual' && Math.random() < 0.002) {
                    state.awareness = 'noticed';
                    state.timers.awareness = 0;
                    setEmotion('surprised');
                } else if (state.awareness === 'noticed' && state.timers.awareness > 2) {
                    if (Math.random() > 0.5) {
                        state.awareness = 'performing';
                        setActivity('dance');
                    } else {
                        state.awareness = 'casual';
                    }
                } else if (state.awareness === 'performing' && state.timers.awareness > 8) {
                    state.awareness = 'casual';
                    state.timers.awareness = 0;
                }
                
                // Activity state machine
                if (state.activity === 'idle' && state.timers.activity > 2) {
                    const activities = ['wander', 'zoom', 'dance'];
                    setActivity(activities[Math.floor(Math.random() * activities.length)]);
                } else if (state.activity === 'wander' && state.timers.activity > 4) {
                    setActivity('return');
                } else if (state.activity === 'zoom' && state.timers.activity > 1) {
                    setActivity('idle');
                } else if (state.activity === 'return') {
                    if (ghostRoot.position.subtract(state.homeBase).length() < 0.5) {
                        setActivity('idle');
                    }
                } else if (state.activity === 'dance' && state.timers.activity > 3) {
                    setActivity('idle');
                }
                
                // Boundary check
                if (Math.abs(ghostRoot.position.x) > 4 || Math.abs(ghostRoot.position.z) > 3) {
                    setActivity('return');
                }
                
                // Apply movement
                ghostRoot.position.x += state.velocity.x;
                ghostRoot.position.z += state.velocity.z;
                
                // Floating animation
                ghostRoot.position.y = Math.sin(time * 1.5) * 0.2 + Math.sin(time * 3.7) * 0.05;
                
                // Body breathing
                const breathe = Math.sin(time * 2) * 0.02;
                ghostBody.scaling.x = 1 + breathe;
                ghostBody.scaling.z = 1 - breathe;
                
                // Face camera
                if (state.awareness === 'noticed' || state.awareness === 'performing') {
                    const lookAt = camera.position.subtract(ghostRoot.position);
                    lookAt.y = 0;
                    const angle = Math.atan2(lookAt.x, lookAt.z);
                    ghostRoot.rotation.y = angle;
                } else if (Math.abs(state.velocity.x) > 0.01 || Math.abs(state.velocity.z) > 0.01) {
                    ghostRoot.rotation.y = Math.atan2(state.velocity.x, state.velocity.z);
                }
                
                // Face always looks at camera
                faceGroup.lookAt(camera.position);
                
                // Arm animations
                if (state.activity === 'dance') {
                    leftArm.rotation.z = Math.sin(time * 10) * 0.8;
                    rightArm.rotation.z = -Math.sin(time * 10 + 0.5) * 0.8;
                } else {
                    leftArm.rotation.z = Math.sin(time * 3) * 0.2;
                    rightArm.rotation.z = -Math.sin(time * 3 + 1) * 0.2;
                }
                
                // Blinking
                if (state.timers.blink > 3 + Math.random() * 2) {
                    leftEye.scaling.y = 0.1;
                    rightEye.scaling.y = 0.1;
                    setTimeout(() => {
                        leftEye.scaling.y = state.emotion === 'sleepy' ? 0.5 : 1.5;
                        rightEye.scaling.y = state.emotion === 'sleepy' ? 0.5 : 1.5;
                    }, 150);
                    state.timers.blink = 0;
                }
                
                // Emotion changes
                if (state.timers.emotion > 5 && state.awareness === 'casual') {
                    const emotions = ['happy', 'excited', 'sleepy', 'surprised'];
                    setEmotion(emotions[Math.floor(Math.random() * emotions.length)]);
                    state.timers.emotion = 0;
                }
                
                // Sounds
                if (state.timers.sound > 8 + Math.random() * 4) {
                    playSound(state.awareness === 'performing' ? 'giggle' : 'boo');
                    state.timers.sound = 0;
                }
                
                // Debug
                document.getElementById('debug').innerHTML = 
                    `Activity: ${state.activity} | Emotion: ${state.emotion} | Awareness: ${state.awareness}`;
            });
            
            // Click handler
            canvas.addEventListener('click', () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                document.getElementById('info').style.display = 'none';
            }, { once: true });
            
            return scene;
        };
        
        const scene = createScene();
        
        engine.runRenderLoop(() => {
            scene.render();
        });
        
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
